# This reusable workflow standardizes dotnet solution publishing to AWS CodeArtifact.
# Supports:
# - Libraries (publish-type: nuget): publish NuGet packages to CodeArtifact
# - Products (publish-type: docker): build & publish Docker images to AWS ECR
#
# Assumes:
# - .NET solution lives under Source/
# - GitHub OIDC federation configured with AWS IAM role
# - All projects enable <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>

name: dotnet-publish-solution-codeartifact

permissions:
  contents: write
  pull-requests: write
  id-token: write

concurrency:
  group: publish-${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_call:
    inputs:
      application:
        type: string
        required: true
        description: "Base app name (without api/contract/ui postfix)"
      dotnet-version:
        type: string
        required: false
        default: "10.x"
        description: ".NET SDK version"
      publish-type:
        type: string
        required: true
        description: "'nuget' for libraries or 'docker' for products"
      package-path:
        type: string
        required: false
        default: "Source/Assemblies"
        description: "Root folder to discover .csproj for packing (nuget only)"
      package-source:
        type: string
        required: true
        description: "CodeArtifact repository name (e.g., ignitia-internal or ignitia-platform)"
      aws-region:
        type: string
        required: false
        default: "eu-west-1"
        description: "AWS region"
      aws-role-arn:
        type: string
        required: true
        description: "IAM role ARN for GitHub OIDC"
      aws-codeartifact-domain:
        type: string
        required: false
        default: "ignitia"
        description: "CodeArtifact domain name"
      aws-parameter-store-github-pat:
        type: string
        required: false
        default: "/ignitia/global/github-pat"
        description: "Parameter Store path for GitHub PAT (cross-repo operations)"
      secret-placeholders:
        type: string
        required: false
        default: ""
        description: "Tilde-separated Parameter Store paths to fetch and use as {{KEY}} placeholders, e.g. '/ignitia/prod/internal/nuget-token~/ignitia/prod/internal/other-secret'"
      repository:
        type: string
        required: true
        description: "Target repo (org/repo) to publish from"

jobs:
  dotnet-publish-solution-codeartifact:
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      # -------------------- AWS OIDC Authentication --------------------
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-role-arn }}
          aws-region: ${{ inputs.aws-region }}

      - name: Fetch GitHub PAT from Parameter Store
        id: github-pat
        run: |
          set -euo pipefail
          PAT=$(aws ssm get-parameter \
            --name "${{ inputs.aws-parameter-store-github-pat }}" \
            --with-decryption \
            --query "Parameter.Value" \
            --output text)
          if [ -z "$PAT" ]; then
            echo "‚ùå Missing GitHub PAT in Parameter Store"
            exit 1
          fi
          echo "::add-mask::$PAT"
          echo "value=$PAT" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Fetched GitHub PAT"

      # -------------------- Checkout --------------------
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository }}
          token: ${{ steps.github-pat.outputs.value }}
          path: workflow/repository
          fetch-depth: 0

      # -------------------- NuGet Placeholder Replacement --------------------
      - name: Detect and replace placeholders in nuget.config
        run: |
          set -euo pipefail
          
          NUGET_CONFIG="workflow/repository/nuget.config"
          
          if [ ! -f "$NUGET_CONFIG" ]; then
            echo "‚ÑπÔ∏è No nuget.config found, skipping"
            exit 0
          fi
          
          PLACEHOLDERS=$(grep -oP '\{\{[A-Za-z0-9_-]+\}\}' "$NUGET_CONFIG" | sort -u || true)
          
          if [ -z "$PLACEHOLDERS" ]; then
            echo "‚ÑπÔ∏è No placeholders in nuget.config"
            exit 0
          fi
          
          echo "üîç Found placeholders:"
          echo "$PLACEHOLDERS"
          
          while IFS= read -r placeholder; do
            key="${placeholder#\{\{}"
            key="${key%\}\}}"
            
            param_name="/ignitia/global/${key,,}"
            param_name="${param_name//_/-}"
            
            echo "üì¶ Fetching: $param_name"
            
            value=$(aws ssm get-parameter \
              --name "$param_name" \
              --with-decryption \
              --query "Parameter.Value" \
              --output text 2>/dev/null) || {
              echo "‚ùå Failed to fetch: $param_name"
              exit 1
            }
            
            echo "::add-mask::$value"
            sed -i "s|$placeholder|$value|g" "$NUGET_CONFIG"
            echo "‚úÖ Replaced $placeholder"
            
          done <<< "$PLACEHOLDERS"

      # -------------------- CodeArtifact Login (adds source if not in nuget.config) --------------------
      - name: Login to CodeArtifact
        run: |
          aws codeartifact login \
            --tool dotnet \
            --domain ${{ inputs.aws-codeartifact-domain }} \
            --repository ${{ inputs.package-source }}
          echo "‚úÖ CodeArtifact source configured"

      # -------------------- Copy nuget.config to expected locations --------------------
      - name: Configure NuGet sources
        run: |
          set -euo pipefail
          
          NUGET_CONFIG="workflow/repository/nuget.config"
          
          if [ -f "$NUGET_CONFIG" ]; then
            mkdir -p ~/.nuget/NuGet
            cp "$NUGET_CONFIG" ~/.nuget/NuGet/NuGet.Config
            cp "$NUGET_CONFIG" workflow/repository/Source/nuget.config
            echo "‚úÖ Copied nuget.config to NuGet locations"
          fi
          
          echo "üìã Configured sources:"
          dotnet nuget list source
      - name: Validate repository structure
        run: |
          set -euo pipefail
          test -d workflow/repository/Source || { echo "‚ùå Missing 'Source' directory at repo root"; exit 1; }
          ls workflow/repository/Source/*.sln >/dev/null 2>&1 || { echo "‚ùå No .sln in Source/"; exit 1; }
          echo "‚úÖ Repository structure valid"

      - name: Validate publish-type input
        run: |
          set -euo pipefail
          case "${{ inputs.publish-type }}" in
            nuget|docker) echo "‚úÖ Publish type: ${{ inputs.publish-type }}" ;;
            *) echo "‚ùå Invalid publish-type: ${{ inputs.publish-type }}"; exit 1 ;;
          esac

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnet-version }}

      # -------------------- Placeholder Replacement --------------------
      - name: Replace placeholders using fetched secrets
        if: inputs.secret-placeholders != ''
        uses: ignitia-core/ignitia-cicd-actions/common-replace-placeholders@master
        with:
          directory: workflow/repository
          replacements-in: ${{ steps.placeholders.outputs.keys }}
          replacements-out: ${{ steps.placeholders.outputs.values }}

      # -------------------- NuGet Configuration --------------------
      - name: Configure NuGet sources from repository nuget.config
        run: |
          set -euo pipefail
          
          NUGET_CONFIG="workflow/repository/nuget.config"
          
          if [ ! -f "$NUGET_CONFIG" ]; then
            echo "‚ùå Error: nuget.config not found at repository root"
            exit 1
          fi
          
          echo "üì¶ Found nuget.config in repository"
          
          mkdir -p ~/.nuget/NuGet
          cp "$NUGET_CONFIG" ~/.nuget/NuGet/NuGet.Config
          echo "‚úÖ Copied to ~/.nuget/NuGet/NuGet.Config"
          
          cp "$NUGET_CONFIG" workflow/repository/Source/nuget.config
          echo "‚úÖ Copied to workflow/repository/Source/nuget.config"
          
          echo ""
          echo "üìã Configured NuGet sources:"
          dotnet nuget list source

      # -------------------- Build / Test --------------------
      - name: dotnet restore (locked)
        run: dotnet restore workflow/repository/Source/*.sln --locked-mode

      - name: dotnet build (Release)
        run: dotnet build workflow/repository/Source/*.sln -c Release --no-restore

      - name: dotnet test (trx)
        run: dotnet test workflow/repository/Source/*.sln -c Release --no-build --logger "trx;LogFileName=TestResults.trx"

      - name: Generate Semantic Version with GitVersion
        id: semver
        uses: ignitia-core/ignitia-cicd-actions/gitversion-generate-semver@master

      # -------------------- Publish --------------------
      - name: Pack NuGet packages
        if: inputs.publish-type == 'nuget'
        run: |
          set -euo pipefail
          find workflow/repository/${{ inputs.package-path }} -name "*.csproj" -print0 | \
            xargs -0 -I {} dotnet pack {} \
              -c Release \
              --no-build \
              -p:PackageVersion=${{ steps.semver.outputs.semantic-version }} \
              -o ./artifacts
          echo "‚úÖ Packed $(ls -1 ./artifacts/*.nupkg 2>/dev/null | wc -l) package(s)"

      - name: Push NuGet packages to CodeArtifact
        if: inputs.publish-type == 'nuget'
        run: |
          set -euo pipefail
          for pkg in ./artifacts/*.nupkg; do
            echo "üì¶ Pushing $(basename "$pkg")..."
            dotnet nuget push "$pkg" \
              --source "${{ inputs.package-source }}" \
              --skip-duplicate
          done
          echo "‚úÖ Published all packages"

      - name: Publish product (Docker to ECR)
        if: inputs.publish-type == 'docker'
        uses: ignitia-core/ignitia-cicd-actions/aws-publish-docker-image@master
        with:
          software-version: ${{ steps.semver.outputs.semantic-version }}
          aws-region: ${{ inputs.aws-region }}
          dotnet-version: ${{ inputs.dotnet-version }}

      # -------------------- Post-publish: tag/release/cleanup/env bump --------------------
      - name: Create Tag & GitHub Release
        if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
        env:
          GH_TOKEN: ${{ steps.github-pat.outputs.value }}
          GIT_AUTHOR_NAME: ci
          GIT_AUTHOR_EMAIL: ci@ignitia
        run: |
          set -euo pipefail
          cd workflow/repository
          
          git config user.name "$GIT_AUTHOR_NAME"
          git config user.email "$GIT_AUTHOR_EMAIL"
          
          tag="${{ steps.semver.outputs.semantic-version }}"
          
          git tag -a "$tag" -m "Release $tag" -f
          git push "https://x-access-token:$GH_TOKEN@github.com/${{ inputs.repository }}" "+refs/tags/$tag"
          
          if gh release view "$tag" --repo "${{ inputs.repository }}" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è Release $tag already exists"
          else
            gh release create "$tag" \
              --repo "${{ inputs.repository }}" \
              --title "Release $tag" \
              --notes "Automated release from CI pipeline" \
              --verify-tag
            echo "‚úÖ Created release $tag"
          fi

      - name: Cleanup Old Releases & Tags
        if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
        uses: ignitia-core/ignitia-cicd-actions/github-clean-releases@master
        with:
          keep: 10
          token: ${{ steps.github-pat.outputs.value }}
          semantic-version: ${{ steps.semver.outputs.semantic-version }}
          clean-prereleases: "true"
          clean-old-releases: "true"

      - name: Bump -environment repo
        if: inputs.publish-type == 'docker' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
        uses: ignitia-core/ignitia-cicd-actions/push-environment@master
        with:
          application: ${{ inputs.application }}
          version: ${{ steps.semver.outputs.semantic-version }}
        env:
          GH_TOKEN: ${{ steps.github-pat.outputs.value }}