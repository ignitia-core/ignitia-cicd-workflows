# This reusable workflow standardizes dotnet solution publishing across all Ignitia repos.
# Supports both:
# - Libraries (publish-type: nuget): Publishes NuGet packages to Azure Artifacts or other NuGet feeds
# - Products (publish-type: docker): Builds and publishes Docker images to AWS ECR
# Assumes:
# - .NET solution lives under Source/
# - For NuGet: nuget.config defines all feeds (and consumes env vars for credentials if needed)
# - For Docker: Dockerfile exists at repository root
# - Key Vault or repo secrets provide required credentials (fetch before restore if private feeds)
# - For NuGet: Package source is passed explicitly (no default to public)
# - For NuGet: All projects have <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile> (or via Directory.Build.props)
# - For Products (docker): Automatically pushes to -environment repo when running on master branch

name: dotnet-publish-solution

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: publish-${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_call:
    inputs:
      application:
        type: string
        required: true
        description: "The name of the application to publish (the name without the api/contract/ui postfix)."
      dotnet-version:
        type: string
        description: ".NET version"
        required: false
        default: "9.x"
      publish-type:
        type: string
        description: "Publish type: 'nuget' for libraries or 'docker' for products"
        required: true
      package-path:
        type: string
        description: "Path to the folder that's the starting point for detecting .csproj files to package (for nuget only)"
        default: "Source/Assemblies"
      package-source:
        type: string
        description: "NuGet package source name (that corresponds with nuget.config) - required for nuget publish-type"
        required: false
      aws-region:
        type: string
        description: "AWS region for ECR (for docker only)"
        required: false
        default: "eu-west-1"
      replacements-in:
        type: string
        description: "Placeholder keys (tilde-separated ~)"
        required: false
        default: ""
      repository:
        type: string
        description: "Repository name in the format 'org/repo'"
        required: true
    secrets:
      github-pat:
        description: "A GitHub Personal Access Token (PAT) with repo access to checkout the target repository."
        required: true
      replacements-out:
        description: "Placeholder values (tilde-separated ~)"
        required: false
      aws-access-key-id:
        description: "AWS access key ID (required for docker publish-type)"
        required: false
      aws-secret-access-key:
        description: "AWS secret access key (required for docker publish-type)"
        required: false

jobs:
  dotnet-publish-solution:
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v5
        with:
          repository: ${{ inputs.repository }}
          token: ${{ secrets.github-pat }}
          path: workflow/repository
          fetch-depth: 0
      - name: Validate repository structure & presence of solution
        shell: bash
        run: |
          set -euo pipefail
          test -d workflow/repository/Source || { echo "‚ùå Missing 'Source' directory at repo root."; exit 1; }
          ls workflow/repository/Source/*.sln >/dev/null 2>&1 || { echo "‚ùå No .sln in Source/"; exit 1; }
      - name: Validate publish-type input
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ inputs.publish-type }}" != "nuget" ] && [ "${{ inputs.publish-type }}" != "docker" ]; then
            echo "‚ùå Invalid publish-type: ${{ inputs.publish-type }}. Must be 'nuget' or 'docker'."
            exit 1
          fi
          if [ "${{ inputs.publish-type }}" == "nuget" ] && [ -z "${{ inputs.package-source }}" ]; then
            echo "‚ùå package-source is required when publish-type is 'nuget'"
            exit 1
          fi
          if [ "${{ inputs.publish-type }}" == "docker" ]; then
            if [ -z "${{ secrets.aws-access-key-id }}" ] || [ -z "${{ secrets.aws-secret-access-key }}" ]; then
              echo "‚ùå aws-access-key-id and aws-secret-access-key secrets are required when publish-type is 'docker'"
              exit 1
            fi
          fi
          echo "‚úÖ Publish type validation passed: ${{ inputs.publish-type }}"
      # Ensure package-path exists (nuget only)
      - name: Validate package-path
        if: inputs.publish-type == 'nuget'
        shell: bash
        run: |
          set -euo pipefail
          test -d "workflow/repository/${{ inputs.package-path }}" \
            || { echo "‚ùå package-path not found: workflow/repository/${{ inputs.package-path }}"; exit 1; }

      # Ensure package-source is resolvable (nuget only)
      - name: Validate NuGet source
        if: inputs.publish-type == 'nuget'
        shell: bash
        run: |
          set -euo pipefail
          src="${{ inputs.package-source }}"
          if [[ "$src" =~ ^https?:// ]]; then
            echo "üîó package-source is a URL: $src"
            exit 0
          fi
          # Check by key in nuget sources (requires nuget.config in repo or user profile)
          if ! dotnet nuget list source | awk '{$1=$1}1' | grep -E "^  ${src} "; then
            echo "‚ùå NuGet source '${src}' not found in 'dotnet nuget list source'. Ensure nuget.config defines it or pass a URL."
            exit 1
          fi
          echo "‚úÖ NuGet source '${src}' found"

      - name: Validate RestorePackagesWithLockFile in all .csproj files
        if: inputs.publish-type == 'nuget'
        shell: bash
        run: |
          set -euo pipefail
          echo "üîç Validating RestorePackagesWithLockFile..."
          INVALID_PROJECTS=()
          GLOBAL_ENABLED=false
          if [ -f "workflow/repository/Source/Directory.Build.props" ] && \
             grep -q '<RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>' "workflow/repository/Source/Directory.Build.props"; then
            echo "‚úÖ Found global RestorePackagesWithLockFile=true in Directory.Build.props"
            GLOBAL_ENABLED=true
          fi
          if [ "$GLOBAL_ENABLED" = false ]; then
            while IFS= read -r csproj; do
              if ! grep -Pzo '(?s)<PropertyGroup[^>]*>.*?<RestorePackagesWithLockFile>\s*true\s*</RestorePackagesWithLockFile>.*?</PropertyGroup>' "$csproj" >/dev/null 2>&1; then
                INVALID_PROJECTS+=("$csproj")
              fi
            done < <(find workflow/repository/Source -name "*.csproj")
            if [ ${#INVALID_PROJECTS[@]} -ne 0 ]; then
              echo "‚ùå Missing <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile> in:"
              printf '  %s\n' "${INVALID_PROJECTS[@]}"
              exit 1
            fi
          fi
          echo "‚úÖ All projects enable RestorePackagesWithLockFile"
      - name: Setup .NET SDK for provided version
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnet-version }}
      - name: Cache NuGet packages
        id: cache-nuget
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
            ~/.local/share/NuGet/v3-cache
          key: ${{ runner.os }}-nuget-${{ hashFiles('workflow/repository/**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
      - name: Log cache status
        shell: bash
        run: |
          if [ "${{ steps.cache-nuget.outputs.cache-hit }}" = "true" ]; then
            echo "‚úÖ NuGet cache hit"
          else
            echo "‚ÑπÔ∏è NuGet cache miss"
          fi
      - name: Replace placeholders
        # This ensures that the secrets (for nuget/azure) are already in place by workflow input
        uses: ignitia-core/ignitia-cicd-actions/common-replace-placeholders@master
        with:
          directory: workflow/repository
          replacements-in: ${{ inputs.replacements-in }}
          replacements-out: ${{ secrets.replacements-out }}
      - name: dotnet restore (locked)
        run: dotnet restore workflow/repository/Source/*.sln --locked-mode
      - name: dotnet build (Release)
        run: dotnet build workflow/repository/Source/*.sln -c Release --no-restore
      - name: dotnet test (trx)
        run: dotnet test workflow/repository/Source/*.sln -c Release --no-build --logger "trx;LogFileName=TestResults.trx"
      - name: Ensure tests executed
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          total=$(grep -hoP 'total=\"\K\d+' **/TestResults.trx 2>/dev/null | awk '{s+=$1} END{print s+0}')
          if [ "${total:-0}" -eq 0 ]; then
            echo "‚ùå No tests executed"; exit 1
          fi
          echo "‚úÖ Total tests executed: $total"
      - name: Upload test results as artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tests-${{ github.run_id }}
          if-no-files-found: ignore
          path: |
            **/TestResults.trx
            **/TestResult.xml
            **/coverage.*
      - name: Generate Semantic Version with GitVersion
        id: semver
        uses: ignitia-core/ignitia-cicd-actions/gitversion-generate-semver@master
      - name: Publish .NET library (NuGet)
        if: inputs.publish-type == 'nuget'
        uses: ignitia-core/ignitia-cicd-actions/dotnet-publish-nuget-packages@master
        with:
          package-path: workflow/repository/${{ inputs.package-path }}
          package-source: ${{ inputs.package-source }}
          package-version: ${{ steps.semver.outputs.semantic-version }}
      - name: Publish product (Docker to ECR)
        if: inputs.publish-type == 'docker'
        uses: ignitia-core/ignitia-cicd-actions/aws-publish-docker-image@master
        with:
          software-version: ${{ steps.semver.outputs.semantic-version }}
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}
          dotnet-version: ${{ inputs.dotnet-version }}
      - name: Tag target repo (annotated, idempotent)
        if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
        shell: bash
        env:
          GIT_AUTHOR_NAME: ci
          GIT_AUTHOR_EMAIL: ci@ignitia
        run: |
          set -euo pipefail
          cd workflow/repository
          git config user.name "$GIT_AUTHOR_NAME"
          git config user.email "$GIT_AUTHOR_EMAIL"
          tag="${{ steps.semver.outputs.semantic-version }}"
          git tag -a "$tag" -m "Release $tag" -f
          git push "https://x-access-token:${{ secrets.github-pat }}@github.com/${{ inputs.repository }}" +refs/tags/$tag
      - name: Cleanup Old Releases & Tags
        if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
        uses: ignitia-core/ignitia-cicd-actions/github-clean-releases@master
        with:
          keep: 10
          token: ${{ secrets.github-pat }}
          semantic-version: ${{ steps.semver.outputs.semantic-version }}
          clean-prereleases: "true"
          clean-old-releases: "true"
      - name: Bump -environment repo
        if: ${{ inputs.publish-type == 'docker' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') }}
        uses: ignitia-core/ignitia-cicd-actions/push-environment@v1
        with:
          application: ${{ inputs.application }}
          version: ${{ steps.semver.outputs.semantic-version }}
        env:
          GH_TOKEN: ${{ secrets.github-pat }}